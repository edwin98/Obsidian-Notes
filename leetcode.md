---
title: LeetCode 高频题目刷题追踪与核心笔记
tags:
  - leetcode
  - python
  - tips
status: polished
---

# LeetCode 高频题目刷题追踪与核心笔记

## 一、数组 / 双指针 / 滑动窗口

- [x] [1. 两数之和](https://leetcode.cn/problems/two-sum/)
- [x] [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
- [ ] [15. 三数之和](https://leetcode.cn/problems/3sum/)
- [ ] [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
- [ ] [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
- [x] [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
- [ ] [283. 移动零](https://leetcode.cn/problems/move-zeroes/)
- [ ] [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
- [ ] [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

---

## 二、哈希表

- [x] [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)
- [ ] [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)
- [x] [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
- [ ] [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

---

## 三、链表

- [ ] [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
- [ ] [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
- [x] [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- [ ] [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
- [ ] [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
- [ ] [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
- [ ] [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

---

## 四、栈 / 单调栈

- [ ] [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)
- [ ] [155. 最小栈](https://leetcode.cn/problems/min-stack/)
- [ ] [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
- [ ] [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)
- [x] [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)
- [ ] [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

---

## 五、二分查找

- [ ] [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
- [ ] [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
- [ ] [69. x 的平方根](https://leetcode.cn/problems/sqrtx/)
- [x] [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
- [x] [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

---

## 六、二叉树 / DFS / BFS

- [ ] [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
- [ ] [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- [ ] [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- [ ] [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [x] [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) #再看看
- [ ] [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)
- [ ] [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

---

## 七、回溯

- [x] [46. 全排列](https://leetcode.cn/problems/permutations/) #再看看 
- [x] [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)
- [ ] [78. 子集](https://leetcode.cn/problems/subsets/)
- [x] [79. 单词搜索](https://leetcode.cn/problems/word-search/)
- [ ] [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

---

## 八、动态规划

### 1. DP 基础
- [x] [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
- [ ] [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
- [ ] [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
- [ ] [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)
- [ ] [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
- [x] [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

### 2. DP 进阶
- [ ] [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
- [ ] [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
- [ ] [494. 目标和](https://leetcode.cn/problems/target-sum/)
- [ ] [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

---

## 九、图 / BFS / 拓扑排序

- [x] [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)
- [ ] [207. 课程表](https://leetcode.cn/problems/course-schedule/)
- [ ] [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)
- [ ] [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

---

## 十、堆 / TopK

- [x] [215. 数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
- [x] [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
- [ ] [703. 数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)

---

## 算法面试核心技巧与笔记

### 1. 数组初始化 (The Foundation)

> [!CAUTION] 致命陷阱：浅拷贝
> **绝对不要**使用 `[[0] * n] * m` 进行二维数组的初始化。这会创建 $m$ 个指向同一个列表对象的引用，导致在[[回溯]]或[[动态规划]]更新状态时，修改一处会连带改变多行（例如 `visited` 数组会发生异常连带变化）。
> 
> ✅ **推荐做法：**
> ```python
> # 初始 m 行 n 列的二维数组
> dp = [[0 for _ in range(n)] for _ in range(m)]
> ```

---

### 2. 哈希表与集合 (Hash & Set)

> [!TIP] 技巧：使用 defaultdict 简化逻辑
> 避免冗长的 `if key not in dict` 初始化操作，使得代码更优雅。
> ```python
> from collections import defaultdict
> 
> # 自动创建默认值为列表的字典
> ans = defaultdict(list) 
> ans[key].append(value)
> 
> # 自动创建默认值为整数（即 0）的计数器字典
> count = defaultdict(int)
> count[key] += 1
> ```

> [!WARNING] 哈希键 (Key) 的要求
> 字典的 **Key** 必须是**不可变类型 (Hashable)**。
> - `List` ❌ -> `tuple(my_list)` ✅
> - `Dict` ❌ -> `tuple(sorted(my_dict.items()))` ✅
> - `Set` ❌ -> `frozenset(my_set)` ✅

---

### 3. 字符串处理 (Strings)

> [!SUCCESS] 性能优化
> 1. **字符索引转换**：在处理小写英文字母分类问题时，使用 `idx = ord(char) - ord('a')` 是必备操作。
> 2. **高效拼接**：在 Python 中，字符串是**不可变**的，因此使用 `s += "a"` 进行循环拼接会导致时间复杂度达到 $O(n^2)$。
>    - 推荐使用 `"".join(list)` 进行替代（时间复杂度为 $O(n)$）。拼接字符串时，可先将需要拼接的片段存入一个 `list` 中，最后统一调用 `join()` 进行组合。

---

### 4. 搜索与递归 (DFS & BFS)

> [!IMPORTANT] 递归深度与队列
> 1. **高效队列 (BFS)**：实现层序遍历等广度优先搜索场景，建议使用 `collections.deque` 来显著提升性能表现。
>    ```python
>    from collections import deque
>    
>    queue = deque([root])
>    node = queue.popleft() # O(1) 操作，而 list.pop(0) 是 O(n) 操作
>    ```

---

### 5. 常用技巧 Cheat Sheet

| 场景 | 推荐语法 |
| :--- | :--- |
| **同时获取索引和值** | `for idx, val in enumerate(nums):` |
| **同时遍历两个列表** | `for a, b in zip(list1, list2):` |
| **反向遍历** | `for i in range(len(nums) - 1, -1, -1):` |
| **极大/极小整数** | `float('inf')` / `float('-inf')` |
| **向下取整除法** | `5 // 2` (结果为 2) |

---

### 6. LeetCode 提交必备

> [!NOTE] 结果转换
> 即使你在实现逻辑时使用了带有特定方法的 `defaultdict` 或 `deque`，在最终返回结果给 LeetCode 时，往往需要安全地将其转换回标准类型（尤其是当函数签名指定类型为 `List` 的时候）：
> - 返回对应字典的特定集合列表：`return list(ans.values())`
> - 将特定的双端队列实体转化为列表：`return list(my_deque)`

---

## heapq 与多路归并 (Merge K Lists) 核心经验总结

### 1. heapq 核心操作

Python 中的 `heapq` 模块默认实现的是**最小堆 (Min-Heap)**，其堆顶元素始终为 `heap[0]`。

**常用时间复杂度操作：**
```python
import heapq

heapq.heappush(heap, x)      # O(log n)
heapq.heappop(heap)          # O(log n)
heapq.heapify(nums)          # O(n)
```

**高频技巧与写法：**
- **最大堆 (Max-Heap) 的实现**：在入堆和出堆时对需要比较的数值添加负号即可。
  ```python
  heapq.heappush(heap, -val)
  ```
- **TopK 问题快捷方法**：利用 `heapq.nlargest(k, nums)` 或是 `heapq.nsmallest(k, nums)` 快速实现。
- **高效替换与优化限制**：使用 `heapq.heappushpop()` 或者 `heapq.heapreplace()` 来维持堆在固定大小。

> [!WARNING] 堆元素本身可比较的陷阱
> 堆中的元素必须必须能够支持 `<` 运算符。当推入属于堆的合并序列的对象包含无法直接可比较的自定义类节点时（例如链表节点 `ListNode`），因为若前面的属性一样则有可能报异常：
> - **错误写法**：`heappush(heap, (priority, node))`（若 `priority` 相同，则会直接尝试进一步去比较无法进行数值判定操作的 `node`）。
> - **正确写法**：应该为其加入能区分每一项自增排序序列索引用以打断进一步值的直接对比过程，即可避开相同的优先级时的判定失败：
>   ```python
>   heappush(heap, (priority, index, node))
>   ```

---

### 2. 链表的核心原则

⭐ **拼接链表意味着这仅仅就是修改 `next` 指针**

> [!info] 补充说明：链表的坏味道
> 绝对不要试图去对属于链表的节点自身直接赋予操作改变（修改节点本身所携带的变量），这对于解链表算法问题属于不当代码实现坏味道，应当仅仅是复用属于同一上下文的节点而已。

- **错误示范**：`cur = node`（这不仅没有实际上的去链接上节点，在多数情形也可能引发对原本该保留的信息发生了丢失）。
- **正确示范**：
  ```python
  cur.next = node
  cur = cur.next
  ```

⭐ **Dummy 虚拟节点辅助模板**：使用虚拟式的头节点可以非常大程度上去省下判空的步骤：
```python
dummy = ListNode(-1)
cur = dummy

# ... 执行遍历与各类属于列表拼接相关的操作 ...
cur.next = node

return dummy.next
```

> [!CAUTION] 高频踩坑操作记录
> - ❌ 尝试直接面向堆中进行无 index 的复合可比类的 `push` -> 引发执行异常崩溃。
> - ❌ 打算去链接节点时直接去使用了 `cur = node` -> 没有真正把要链接的节点链接进去原本属于的所在链表尾。
> - ❌ 结束完成指针的循环链接以后由于忘掉接着把游标游动向下 (`cur = cur.next`) 发生无休止覆盖。

---

### 3. 本质的思维认知归纳
- **堆 (`heapq`)**：本质解决的是属于**动态求出最值的过程维护**类问题，切记不要把它仅仅去当成普通式的排序手段来看待。
- **链表 (`LinkedList`)**：实操的关键核心为改变的是 `next` 指向状态联系。

> [!info] TopK 问题思维导向
> **找最大用最小堆，找最小用最大堆**
> 当需要在一些很大规模属于动态性的数据结构中想去取找前 K 个特定的处于极大位置的目标值的时候，常常的做法是在起初创建一个特定规格为大小 K 的**最小堆**配置，在向后延续扫描过程中持续不断的用堆顶的元素去发生对比操作去剔除掉小的数值结果。

---

## 二分法的设置经验整理

### 第一步：看“死循环”——决定循环的限制条件

- **搜到一个特定值即可宣布终止**：如果你实际的情况属于在搜查过程中可以在命中的阶段直接 `return mid` 作为答案出口的（例如找到了所需的那一项便可以收场），应当使用 **`while left <= right:`**。

- **是在找出一个最终的“边界范围”或者是“极端的最值判定”**：（通常属于这个寻找过程到结尾的范围边界时才进行最终判定）：应当使用 **`while left < right:`**。

### 第二步：看“被排除性”——决定左右边的指针怎样位移

> [!TIP] 这是实现二分的命脉逻辑环节：
> **如果判定出当下的 `mid` 值绝对不可能作为预期需要的答案部分时，才可以进行 $+1$ 或是 $-1$ 的偏移！**

- `left = mid + 1`：这代表此条件被验证的情况下 `mid` 已经肯定没戏了。
- `right = mid`：代表这个 `mid` 在当下依然还保留着很有**可能**成为边界的最后一块拼图的一部分，因此并不能够果断将它抛弃（如果是 `right = mid - 1` 这必然引发错过了包含结果本身的危险）。

### 第三步：看“潜在越界的发生”——正确地确定右方 `right` 的原始点
- 当本身写下的判定核心条件判断有直接引用使用比较 `nums[mid + 1]` 进行操作时：`right` 的初始值点一定要设定为 **`len(nums) - 1`** 规避执行的跑偏导致列表数组异常终止崩溃。
- 若只包含只使用并单纯的看当前判定中心项的数据如 `nums[mid]` 这类型操作本身时，`right` 最开始设为 `len(nums) - 1` 与设为 `len(nums)` 一般都能奏效（但这通常取决于上面第一步时采用条件的使用范围策略），为了避免混乱和维护成本一般依然最强烈建议全局统一的使用 `len(nums) - 1` 能让整体最清晰不过。